#!/usr/bin/env python

import sys
import ipaddress
from optparse import OptionParser
from math import floor
from filereader import get_communities_data


ICVPN_NETWORKS = {
    "IPv4": ipaddress.IPv4Network("10.207.0.0/16"),
    "IPv6": ipaddress.IPv6Network("fec0::a:cf:0:0/96"),
}


class ValidationException(Exception):
    counter = 0
    color = '\033[m'

    def __init__(self, community, msg):
        self.__class__.counter += 1
        print("%s[%s] %s\033[m" % (self.color, community, msg),
              file=sys.stderr)
        super().__init__("[%s] %s" % (community, msg))


class ValidationWarning(ValidationException):
    color = '\033[93m'


class ValidationError(ValidationException):
    color = '\033[91m'


def ip_family_address(family, address):
    obj = getattr(ipaddress, family + "Address")
    return obj(address)


def ip_family_network(family, network):
    obj = getattr(ipaddress, family + "Network")
    return obj(network)


def check_dupe(name, v, d, community):
    if v in d:
        ValidationError(community, "Duplicate %s (%s): %s" % (name, v, d[v]))
        return 1
    else:
        d[v] = community
        return 0


def check_net(family, net, nets, community):
    try:
        net = ip_family_network(family, net)
    except ValueError:
        ValidationError(community, "Not an %s network: %s" % (family, net))
    else:
        for other in nets:
            if other.overlaps(net):
                ValidationError(
                    community,
                    "%s network overlap: %s (%s), %s (%s)" %
                    (family, community, net, nets[other], other)
                )

        # we want to detect all possible network collisions, so we have to add
        # even networks that had collisions to our dict
        nets[net] = community


def do_checks(srcdir):
    """
    Check files for sanity.
    """

    asns = dict()
    bgp_gw = dict()
    bgp_gw_ip = dict()
    networks = {
        'IPv4': {ICVPN_NETWORKS['IPv4']: 'transfer'},
        'IPv6': {ICVPN_NETWORKS['IPv6']: 'transfer'},
    }

    def filereader_error_handler(community):
        ValidationError(community, "Invalid YAML")

    for community, data in get_communities_data(srcdir, [],
                                                filereader_error_handler):
        orig_errcnt = 0
        if 'asn' in data:
            check_dupe("ASN", data['asn'], asns, community)

        for bgp in data.get('bgp', []):
            check_dupe("BGP peer name", bgp, bgp_gw, community)

            lastbytes = set()

            for ipclass in data['bgp'][bgp]:
                upipclass = ipclass[:2].upper() + ipclass[2:]
                try:
                    ip = ip_family_address(upipclass,
                                           data['bgp'][bgp][ipclass])
                except ValueError:
                    ValidationError(community,
                                    "Not an %s BGP address: %s" %
                                    (upipclass, data['bgp'][bgp][ipclass]))

                check_dupe("BGP address", ip, bgp_gw_ip, community)
                try:
                    network = ICVPN_NETWORKS[upipclass]
                except KeyError:
                    ValidationWarning(community,
                                      "Unknown BGP protocol class: %s" %
                                      upipclass)
                    continue

                if ip not in network:
                    ValidationError(community,
                                    "%s BGP address in wrong subnet: %s" %
                                    (upipclass, data['bgp'][bgp][ipclass]))

                # we want that the last half of the host part of the
                # address spaces contains the same numeric value for all
                # protocol version
                # i.e. last 8 bits of IPv4 = last 16 bits of IPv6
                # i.e. IPv6 has to be padded with 8 zeroes
                matchbits = floor((ip.max_prefixlen - network.prefixlen)/2)
                lastbytes.add(int(ip) % (1 << matchbits))

            if len(lastbytes) != 1:
                ValidationWarning(community,
                                  "Last part of BGP addresses differs: %s" %
                                  lastbytes)

        if 'networks' in data:
            for family in ('IPv4', 'IPv6'):
                if family.lower() in data['networks']:
                    for net in data['networks'][family.lower()]:
                        check_net(family, net, networks[family], community)

    print("%d error(s), %d warning(s)" %
          (ValidationError.counter, ValidationWarning.counter))

    return 0 if ValidationError.counter == 0 else 1

if __name__ == "__main__":
    parser = OptionParser()
    parser.add_option("-s", "--sourcedir", dest="src",
                      help="Use files in DIR as input files. Default: data/",
                      metavar="DIR",
                      default="data")

    (options, args) = parser.parse_args()

    ret = do_checks(options.src)

    sys.exit(ret)
